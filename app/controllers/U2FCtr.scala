/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at

 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package controllers

import play.api._
import play.api.mvc._
import play.api.data._
import play.api.libs.json._
import play.api.libs.json.Json._

import utils._
import models._

object U2FCtr extends Controller {

  def log(text:String) = Logger.debug(text)

  // Set to false to ignore challenge errors
  def CHECK_CHALLENGE = true

  // Set to false to allow untrusted certificates
  def CHECK_CERTIFICATE = false

  // Set to false to disable counter check
  def CHECK_COUNTER = true

  /**
   * Challenge generated by the server for registration
   * uid -> challenge
   */
  private val challenges = new scala.collection.mutable.LinkedHashMap[String, String]()
    with scala.collection.mutable.SynchronizedMap[String, String]

  def genDeviceChallenges(uid:String, devices:List[U2FDevice]) = {
    devices.map(
      d => (d.keyHandle, U2F.genChallenge())
    )
  }

  def genChallenge = AuthController.GetAuthState {
    implicit r => implicit st => st match {
      case Unlogged() => Ajax.JSONerr("offline")
      case Logged(uid, _) => {
        val challenge = U2F.genChallenge()
        challenges += (uid -> challenge)
        Ok(Json.obj(
          "ok" -> Json.obj(
            "challenge" -> challenge,
            "challengeHash" -> U2F.hashToHex(challenge)
          )
        ))
      }
    }
  }

  def cleanChallenges(uid:String) {
    challenges -= uid
  }

  def deviceRegister = AuthController.GetAuthState {
    implicit r => implicit st => st match {
      case Unlogged() => Redirect("/")
      case Logged(_, _) =>
        Ok(views.html.deviceRegister())
    }
  }

  def checkRegister = AuthController.GetAuthState {
    implicit r => {
      case Logged(uid, _) => {
        U2F.checkRegister(uid, r, challenges.get(uid)) match {
          case RegisterFailure(msg) => {
            cleanChallenges(uid)
            log(msg)
            Ajax.JSONerr(msg)
          }
          case RegisterSuccess(kh, pp, k, crt) => {
            cleanChallenges(uid)
            val device = U2FDevice(
              Utils.genID(64),
              new java.util.Date(), uid,
              kh, pp, k, crt
            )
            U2FDevice.insert(device)
            Ajax.JSONok("done")
          }
        }
      }
      case Unlogged() => Ajax.JSONerr("offline")
    }
  }

  def checkSign = Action {
    implicit r => {
      var err = ""
      AuthController.UpdateAuthState{
        case Unlogged() => Unlogged()
        case Logged(uid, Pending(oath, true, challenges)) => {
          def onError(msg:String) = {
            log(msg)
            err = msg
            Logged(uid, Pending(oath, true, challenges))
          }
          val devices = U2FDevice.findByOwner(uid)
          U2F.checkSign(uid, r, devices, challenges) match {
            case SignSuccess(kh) => Logged(uid, U2FSuccess(kh))
            case SignFailure(msg) => onError(msg)
          }
        }
        case Logged(uid, _) => {
          err = "No U2F authentication required"
          Logged(uid, No2F())
        }
      }{
        case Unlogged() => Ajax.JSONerr("offline")
        case Logged(_, U2FSuccess(_)) => Ajax.JSONok("success")
        case Logged(_, _) => Ajax.JSONerr("Authentication failed (%s)".format(err))
      }(r)
    }
  }

  def deleteDevice = AuthController.GetAuthState {
    implicit r => implicit st => st match {
      case Unlogged() => Ajax.JSONerr("offline")
      case Logged(uid, u2f) =>
        u2f match {
          case Pending(_, _, _) => Ajax.JSONerr("Second factor pending")
          case _ => {
            val data = Ajax.getData(r)
            val id = data("id")
            U2FDevice.remove(id, uid)
            Ajax.JSONok("ok")
          }
        }
    }
  }

  /* Electronic signing */

  def signature = AuthController.GetAuthState {
    implicit r => implicit st => st match {
      case Logged(uid, U2FSuccess(kh)) => {
        U2FDevice.findByOwnerAndKH(uid, kh) match {
          case None => Ok(views.html.signature(kh, ""))
          case Some(k) => Ok(views.html.signature(kh, k.public))
        }
      }
      case _ => Ok(views.html.signature("", ""))
    }
  }

  /* Routes for device checker */

  def checkDevice = AuthController.GetAuthState {
    implicit r => implicit st => {
      Ok(views.html.deviceCheck())
    }
  }


  def getCheckChallenge = Action {
    implicit r =>  {
      Ok(Json.obj( "challenge" -> U2F.genChallenge() ))
    }
  }

  def checkRegister2 = Action {
    implicit r => {
      val res = U2F.getRegisterResponse(r)
      U2F.checkRegister("", r, Some(res.challenge)) match {
        case RegisterFailure(msg) => {
          log(msg)
          Ajax.JSONerr(msg)
        }
        case RegisterSuccess(kh, pp, k, crt) => {
          Ok(Json.obj(
            "ok" -> Json.obj(
              "keyHandle" -> kh,
              "pubPoint" -> pp,
              "kind" -> k,
              "cert" -> crt,
              "challenge" -> U2F.genChallenge()
            )
          ))
        }
      }
    }
  }

  def checkSign2 = Action {
    implicit r => {
      val data = Ajax.getData(r)
      val fakeDevices = List(U2FDevice(
        "", new java.util.Date(), "",
        data("keyHandle"),
        data("pubPoint"),
        data("kind"),
        Some(data("cert"))
      ))
      val challenges = List(
        (data("keyHandle"), data("challenge"))
      )
      U2F.checkSign("", r, fakeDevices, challenges) match {
        case SignSuccess(_) =>
          val msg = data("cert") match {
            case "plugup-fidoCA.pem" => "Your device is a genuine Plug-up dongle"
            case _ => "Your device is an unknown U2F dongle"
          }
          Ajax.JSONok(msg)
        case SignFailure(msg) => Ajax.JSONerr(msg)
      }
    }
  }

}
