/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at

 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package controllers

import play.api._
import play.api.mvc._
import play.api.data._
import play.api.libs.json._
import play.api.libs.json.Json._

import utils._
import models._

object U2FCtr extends Controller {

  def log(text:String) { U2F.log(text) }

  // Set to false to ignore challenge errors
  def CHECK_CHALLENGE = true

  // Set to false to allow untrusted certificates
  def CHECK_CERTIFICATE = false

  // Set to false to disable counter check
  def CHECK_COUNTER = true

  /**
   * Challenge generated by the server for registration
   * uid -> challenge
   */
  private val challenges = new scala.collection.mutable.LinkedHashMap[String, String]()
    with scala.collection.mutable.SynchronizedMap[String, String]

  def genDeviceChallenges(uid:String, devices:List[U2FDevice]) = {
    devices.map(
      d => (d.keyHandle, U2F.genChallenge())
    )
  }

  def genChallenge = AuthController.GetAuthState {
    implicit r => implicit st => st match {
      case Unlogged() => Ajax.JSONerr("offline")
      case Logged(uid, _) => {
        val challenge = U2F.genChallenge()
        challenges += (uid -> challenge)
        Ok(Json.obj(
          "ok" -> Json.obj(
            "challenge" -> challenge,
            "challengeHash" -> U2F.hashToHex(challenge)
          )
        ))
      }
    }
  }

  def cleanChallenges(uid:String) {
    challenges -= uid
  }

  def deviceRegister = AuthController.GetAuthState {
    implicit r => implicit st => st match {
      case Unlogged() => Redirect("/")
      case Logged(_, _) =>
        Ok(views.html.deviceRegister())
    }
  }

  def doCheckRegister(uid:String, r: RegisterResponse) = {
    log("Checking registration data for "+uid)

    log("BrowserData: " + r.browserData)
    log("EnrollData: " + Utils.bytesToHex(r.enrollData))

    if (Utils.byte2Int(r.enrollData(0)) != 5) {
      RegisterFailure("Error registering device: invalid first byte (RFU)")
    } else if (Utils.byte2Int(r.enrollData(1)) != 4) {
      RegisterFailure("Error registering device: invalid second byte (version)")
    } else {
      val publicPoint = r.enrollData.slice(1, 66)
      log("User public point: " + Utils.bytesToHex(publicPoint))
      val khLength = java.lang.Byte.valueOf(r.enrollData(66))
      val keyHandle = r.enrollData.slice(67, 67+khLength)
      log("User key handle: " + Utils.bytesToHex(keyHandle))
      val certOffset = 67+khLength
      val mode = Utils.byte2Int(r.enrollData(certOffset+1))
      val (certSize, sizeLen):(Int, Int) =
        if (mode == 0x81) {
          (Utils.byte2Int(r.enrollData(2+certOffset)), 2)
        } else if (mode == 0x82) {
          (0x0100 * Utils.byte2Int(r.enrollData(2+certOffset)) + Utils.byte2Int(r.enrollData(3+certOffset)), 3)
        } else (mode, 1);
      val attestCert = r.enrollData.slice(certOffset, certOffset + certSize + sizeLen + 1)
      log("Attestation certificate: " + Utils.bytesToHex(attestCert))
      val certCheck = U2F.checkAttestCrt(attestCert)
      if (certCheck.isEmpty && CHECK_CERTIFICATE) {
        RegisterFailure("Certitifcate is not trusted")
      } else {
        if (certCheck.isEmpty) log("Certitifcate is not trusted but error ignored")
        else log("Trusted certificate")
        val sigOffset = certOffset + certSize + sizeLen + 1
        val sigLen = Utils.byte2Int(r.enrollData(sigOffset + 1))
        val signature = r.enrollData.slice(sigOffset, sigOffset + sigLen + 2)

        val attestCertHex = Utils.bytesToHex(attestCert)
        // Quick hack, look for ECPublicKey / Prime256v1 OIDs and start of sequence
        val OIDLookup = "06072A8648CE3D020106082A8648CE3D030107034200"
        val OIDIndex = attestCertHex.indexOf(OIDLookup)
        if (OIDIndex < 0) {
          RegisterFailure("Error registering device: Certificate error (OIDs not found)")
        } else {
          val finalIdx = (OIDIndex + OIDLookup.length) / 2
          val attestPublic = U2F.getPublicKey(attestCert).get
          log("Attestation public: " + Utils.bytesToHex(attestPublic))
          log("Challenge " + r.challenge)
          // TODO: check challenge

          val dataToSign = Array(
            Array(0.toByte),
            r.appHash, r.chHash,
            keyHandle, publicPoint
          ).flatten
          log("AttestPub: "+Utils.bytesToHex(attestPublic))
          log("Data to sign: "+Utils.bytesToHex(dataToSign))
          log("Signature: "+Utils.bytesToHex(signature))
          if (U2F.verifySignature(attestPublic, dataToSign, signature)) {
            log("Everything is OK !")
            cleanChallenges(uid)
            RegisterSuccess(
              Base64.encode(keyHandle), Utils.bytesToHex(publicPoint),
              "SHA256withECDSA", certCheck
            )
          } else RegisterFailure("Error registering device (invalid signature)")
        }
      }
    }
  }

  def getRegisterResponse(r: Request[AnyContent]) = {
    val data = Ajax.getData(r)
    val browserData = data("clientData")
    val decodedBrowserData = Utils.bytesToString(Base64.decode(browserData))
    val enrollData = data("registrationData")
    val decodedEnrollData = Base64.decode(enrollData)
    val appId = gs.HOST()
    val appHash = U2F.hashStringData(appId)
    val challenge = data("challenge")
    val chHash = U2F.hashStringData(decodedBrowserData)

    RegisterResponse(
      data("version"), appId, appHash,
      data("sessionId"), challenge,
      decodedBrowserData, chHash,
      decodedEnrollData
    )
  }

  def checkRegister = AuthController.GetAuthState {
    implicit r => {
      case Logged(uid, _) => {
        doCheckRegister(uid, getRegisterResponse(r)) match {
          case RegisterFailure(msg) => 
            log(msg)
          Ajax.JSONerr(msg)
          case RegisterSuccess(kh, pp, k, crt) => {
            val device = U2FDevice(
              Utils.genID(64),
              new java.util.Date(), uid,
              kh, pp, k, crt
            )
            U2FDevice.insert(device)
            Ajax.JSONok("done")
          }
        }
      }
      case Unlogged() => Ajax.JSONerr("offline")
    }
  }

  def doCheckSign(uid:String, r: SignResponse, challenges:List[(String, String)]) = {
    log("Checking signature data for "+uid)

    log("BrowserData: " + r.browserData)
    log("SignData: " + Utils.bytesToHex(r.signature))

    val flag = r.signature(0)
    val counter = r.signature.slice(1, 5)
    val counterVal = java.lang.Long.parseLong(Utils.bytesToHex(counter), 16)
    
    log("Counter: " + Utils.bytesToHex(counter) + "("+ counterVal.toString +")")
    val signatureSize = Utils.byte2Int(r.signature(6))
    val signature = r.signature.slice(5, 7 + signatureSize)
    log("Signature: " + Utils.bytesToHex(signature))

    log("Key handle: " + Utils.bytesToHex(Base64.decode(r.keyHandle)))

    def searchPublicPoint() = {
      U2FDevice.findByOwnerAndKH(uid, r.keyHandle) match {
        case None => SignFailure("Unknow device")
        case Some(d) => {
          if (d.counter.isDefined && d.counter.get >= counterVal && CHECK_COUNTER)
            SignFailure("Invalid counter !")
          else {
            val pt = Utils.hexToBytes(d.public)

            val dataToSign = Array[Array[Byte]](
              r.appHash, Array(flag),
              counter, r.chHash
            ).flatten
            log("Public pt: "+Utils.bytesToHex(pt))
            log("Data to sign: "+Utils.bytesToHex(dataToSign))
            log("Signature: "+Utils.bytesToHex(signature))
            val res = U2F.verifySignature(pt, dataToSign, signature)
            if (res) {
              log("Sign success !")
              U2FDevice.setCounter(d._id, counterVal)
              SignSuccess()
            } else SignFailure("Invalid signature")
          }
        }
      }
    }

    challenges.find(_._1 == r.keyHandle) match {
      case None => {
        if (CHECK_CHALLENGE)
          SignFailure("No challenge generated for this device !")
        else searchPublicPoint()
      }
      case Some((kh, challenge)) => {
        log(challenge)
        val challHash = U2F.hashToHex(challenge)
        // Note: the hash is checked only for Plug-up extension
        if (r.browserData.indexOf(challenge) >= 0 || r.browserData.indexOf(challHash) >= 0) searchPublicPoint()
        else if (CHECK_CHALLENGE) SignFailure("Challenge tampered !")
        else searchPublicPoint()
      }
    }
  }

  def getSignResponse(r: Request[AnyContent]) = {
    val data = Ajax.getData(r)
    val browserData = data("clientData")
    val decodedBrowserData = Utils.bytesToString(Base64.decode(browserData))
    val signData = data("signatureData")
    val decodedSignData = Base64.decode(signData)
    val appId = gs.HOST()
    val appHash = U2F.hashStringData(appId)
    val challenge = data("challenge")
    val chHash = U2F.hashStringData(decodedBrowserData)
    val keyHandle = data("keyHandle")
    val b64kh = keyHandle
    SignResponse(
      data("version"), appId, appHash,
      data("sessionId"), b64kh,
      challenge, decodedBrowserData,
      chHash, decodedSignData
    )
  }

  def checkSign = Action {
    implicit r => {
      var err = ""
      AuthController.UpdateAuthState{
        case Unlogged() => Unlogged()
        case Logged(uid, Pending(oath, true, challenges)) => {
          doCheckSign(uid, getSignResponse(r), challenges) match {
            case SignSuccess() => Logged(uid, U2FSuccess())
            case SignFailure(msg) => {
              log(msg)
              err = msg
              Logged(uid, Pending(oath, true, challenges))
            }
          }
        }
        case Logged(uid, _) => {
          err = "No U2F authentication required"
          Logged(uid, No2F())
        }
      }{
        case Unlogged() => Ajax.JSONerr("offline")
        case Logged(_, U2FSuccess()) => Ajax.JSONok("success")
        case Logged(_, _) => Ajax.JSONerr("Authentication failed (%s)".format(err))
      }(r)
    }
  }

  def deleteDevice = AuthController.GetAuthState {
    implicit r => implicit st => st match {
      case Unlogged() => Ajax.JSONerr("offline")
      case Logged(uid, u2f) =>
        u2f match {
          case Pending(_, _, _) => Ajax.JSONerr("Second factor pending")
          case _ => {
            val data = Ajax.getData(r)
            val id = data("id")
            U2FDevice.remove(id, uid)
            Ajax.JSONok("ok")
          }
        }
    }
  }

}
